# 함수 (function)

> 변수 = 값
>
> 함수 = 명령들

**함수는 다양한 명령들을 저장하는 것**이라고 생각하면 된다. 변수가 **값**을 저장하는 것처럼, **함수는 여러 명령들을 저장**하는 역할을 한다. 함수를 사용하면 복잡한 명령을 **간결하게 묶어서 관리**할 수 있으며, 나중에 **반복적으로 사용할 때** 특히 유용하다.

## 함수 선언

변수를 사용할 때처럼, **함수도 선언**을 먼저 해야 한다.

함수는 **`function`**이라는 키워드를 사용해서 선언할 수 있다. **`function`** 뒤에 함수의 **이름**을 적고, 그 뒤에 **소괄호 `()`**를 쓴다. 그다음, **중괄호 `{}`** 안에 실행할 **명령들**을 작성하면 된다.

```jsx
// 함수 선언
function 함수이름() {
  명령들;
}
```

이렇게 한 줄로 작성할 수도 있지만, 일반적으로는 **가독성을 위해** 줄바꿈을 사용하고, **명령어들은 한 줄에 하나씩** 작성하는 것이 좋다. 특히 명령어들이 많을 때, 줄바꿈을 통해 코드가 더 깔끔하게 보인다.

```jsx
// 함수 선언
function 함수이름() {
  명령;
  명령;
}
```

### 함수 예시: 여러 나라의 인사말 출력

**함수의 예시**로, **여러 나라의 인사말**을 한 번에 출력하는 `printGreetings`라는 함수를 만들어본다.

함수 안에 이전에 많이 사용했던 **`console.log()`** 명령어를 넣어서 **한 번에 여러 인사말을 출력**할 수 있다.

```jsx
// 함수 선언: 여러 인사말을 출력하는 함수
function printGreetings() {
  console.log("안녕하세요"); // 한국어 인사
  console.log("Hello"); // 영어 인사
  console.log("Hola"); // 스페인어 인사
  console.log("Bonjour"); // 프랑스어 인사
  console.log("こんにちは"); // 일본어 인사
}
```

이 함수는 **다양한 나라의 인사말**을 출력하는 명령어들을 하나로 묶어 두었다. 함수 안에 있는 **`console.log()`** 명령어들이 한 번에 실행되도록 만들어진 함수다.

그런데 저장하고 실행해 보면 아무것도 나타나는 게 없다.

> 함수 선언은 그 함수가 사용될 때 어떤 행동을 할지 정의만 하는 것이다.

## 함수 호출

함수를 선언한 후에는, 실제로 **함수를 호출**해야 실행된다.

함수를 호출하려면, **함수 이름 뒤에 소괄호 `()`**를 붙여서 실행할 수 있다. 함수가 호출되면, 그 안에 작성된 명령어들이 **순서대로 실행**된다.

```jsx
// 함수 호출
printGreetings();
```

이 코드를 실행하면, 여러 나라의 인사말이 한 번에 출력된다:

!https://velog.velcdn.com/images/moon_dev/post/86aef188-bae6-44f5-a550-976ce34c3f55/image.png

### 함수의 장점: 반복 작업을 간결하게

함수는 여러 명령어들을 **하나의 이름**으로 묶어서 사용할 수 있기 때문에, 코드의 **가독성**과 **재사용성**을 높여준다. 예를 들어, 여러 번 인사말을 출력해야 할 때, 매번 `console.log()`를 쓰는 대신 **함수를 호출**하면 된다.

```jsx
// 함수 호출을 여러 번 사용해보자
printGreetings();
printGreetings();
```

이렇게 함수를 여러 번 호출하면, **한 번 작성된 명령을 반복**해서 실행할 수 있다. 함수를 사용하면 **복잡한 작업을 단순하게 관리**할 수 있다.

**`console.log()`**를 여러 번 반복해서 쓰지 않고도, 함수를 호출함으로써 쉽게 같은 작업을 할 수 있다.

---

## 함수 실습 문제

지금까지 배운 내용을 바탕으로 함수를 작성하고 호출하는 연습을 하면서 개념을 더 확실히 할 필요가 있다. 아래 문제들을 풀어보면서 직접 함수를 작성하고 실행해본다.

### 1. **기본적인 함수 작성**

- 이름이 **`sayHi`**인 함수를 작성해서, 그 안에 **`console.log('Hi!')`** 명령어를 넣고 출력한다.

```jsx
function sayHi() {
  console.log("Hi!");
}

sayHi(); // 예상 출력: Hi!
```

### 2. **여러 명령어를 가진 함수 작성**

- 이름이 **`showPersonalInfo`**인 함수를 작성하고, 그 안에 **이름**, **나이**, **좋아하는 음식을 출력**하는 `console.log()` 명령어를 넣어서 출력한다.

```jsx
function showPersonalInfo() {
  console.log("이름: 홍길동");
  console.log("나이: 25살");
  console.log("좋아하는 음식: 떡볶이");
}

showPersonalInfo();
/* 예상 출력:
이름: 홍길동
나이: 25살
좋아하는 음식: 떡볶이
*/
```

### 3. **반복적인 작업을 처리하는 함수**

- **`greetTwice`**라는 함수를 작성하고, 그 안에 **인사말**을 두 번 출력하는 `console.log()` 명령어를 넣는다.

```jsx
function greetTwice() {
  console.log("Hello!");
  console.log("Hello!");
}

greetTwice();
/* 예상 출력:
Hello!
Hello!
*/
```

### 4. **함수 호출을 반복**

- 위에서 작성한 **`greetTwice`** 함수를 **두 번 호출**하면 인사말이 네 번 출력된다.

```jsx
greetTwice();
greetTwice();
/* 예상 출력:
Hello!
Hello!
Hello!
Hello!
*/
```

> 함수는 여러 명령들을 하나로 묶어서 관리하는 방식이다. 변수가 값을 저장하는 것처럼, 함수는 명령어들을 저장한다.

> 콘솔에 값을 출력할 때 사용했던 console.log도 사실 JavaScript를 만든 개발자들이 미리 작성해 둔 함수다. 겉으로 보기엔 콘솔에 값을 출력하는 간단한 기능처럼 보이지만, 실제로는 그 안에 복잡한 명령어들이 들어 있을 수 있다.
>
> 그런데 함수 이름인 `console.log`만 알면 내부 동작을 몰라도 바로 사용할 수 있다. 이런 식으로 함수 내부의 복잡한 부분은 감추고, 이름을 통해 핵심 기능만 드러내는 것이 함수에서의 **추상화**다.

---

### 요약

> 함수는 function 키워드를 사용해 선언한다. function 뒤에 함수의 이름을 적고, 그 뒤에 소괄호 ()를 쓴다. 그다음, 중괄호 {} 안에 실행할 명령들을 작성하면 된다.console.log() 같은 명령어를 함수 안에 넣을 수 있다.함수를 호출할 때는 함수 이름 뒤에 소괄호 ()를 붙인다.

# 파라미터

## **파라미터**(parameter)란 무엇인가?

**파라미터**는 함수에 **입력으로 전달되는 값**을 받기 위한 변수다. 함수를 선언할 때 **소괄호 안에 작성**되는 것이 바로 파라미터다.

이 파라미터는 **함수가 호출될 때** 전달되는 값을 받아, 함수 내부에서 그 값을 **변수처럼** 사용할 수 있다.

```jsx
//함수 선언
function 함수이름(파라미터) {
  // 매개변수 = 파라미터(parameter)
  console.log(파라미터);
}

//함수 호출
함수이름(값); // 값 = 인자(argument)
```

예를들면 **배달** 갈 때 "**여기 치킨 한 마리 배달 좀 해주세요**" 이렇게 주문을 받잖아? 여기서 '**치킨**` 한 마리가 **함수**한테 주어진 **파라미터** 같은 거임. 함수는 "_아~ 치킨? 오케이!_" 하면서 그걸 받아서 처리함.

```jsx
// 함수 선언
function 배달(물건) {
  // '물건'이 파라미터
  console.log(물건 + " 배달 완료!");
}

// 함수 호출
배달("치킨"); // 여기가 인자(치킨) 전달하는 부분!

//console.log 출력: 치킨 배달 완료!
```

위 코드에서, `물건`은 **파라미터**이고 `치킨`은 **인자**다. 파라미터는 "내가 무엇이든 받을 준비가 되어있다!"라는 입장이고, 인자는 실제로 전달된 값을 의미한다.

!https://velog.velcdn.com/images/moon_dev/post/7fe2ccd0-f023-4b24-ac0b-d21e7bc21a5e/image.png

요약하자면:

**`파라미터`**는 그냥 함수가 일단 받아둘 자리 표시.

**`인자`**는 함수에 진짜로 넘겨주는 값.

> 그래서 이게 진짜 좋은 게 뭐냐면, 함수를 한 번 만들어 두면 치킨만이 아니라 피자, 햄버거… 뭐든지 배달 시킬 수 있다는 거임. 유연하다고! 👀

### 파라미터의 개념 예시

파라미터를 사용하면 하나의 함수로 여러 상황을 유연하게 처리할 수 있다. 예를 들어, 인사말을 출력하는 함수를 생각해보자. **파라미터 없이 작성한 함수**는 고정된 메시지만 출력한다.

```jsx
// 파라미터 없이 고정된 인사말 출력
function greet() {
  console.log("Hello, John!");
}

greet(); // 출력: Hello, John!
```

이 함수는 무조건 'Hello, John!'이라고만 인사말을 출력한다. 그러나 **파라미터**를 사용하면 이름을 **유동적**으로 바꿔가며 인사를 할 수 있게 된다.

**파라미터**를 사용하면, 함수를 호출할 때마다 **다른 값을 전달**할 수 있다. 이를 통해 함수는 입력에 따라 **다양한 동작**을 할 수 있게 된다. 다음은 이름을 파라미터로 받아서 **유동적인 인사말**을 출력하는 함수의 예시다.

```jsx
// 파라미터로 이름을 받아서 인사말 출력
function greet(name) {
  console.log("Hello, " + name + "!");
}

greet("Alice"); // 출력: Hello, Alice!
greet("Bob"); // 출력: Hello, Bob!
```

여기서 `name`이라는 **파라미터**가 등장한다. 이 파라미터는 함수를 호출할 때 **소괄호 안에 전달된 값**을 받는다.

`greet('Alice')`를 호출하면, 'Alice'라는 값이 `name`**파라미터**로 전달되어 **`console.log()`** 내부에서 사용된다. 이렇게 **파라미터**를 활용하면, 함수를 더 **유연하게** 사용할 수 있다.

## 파라미터의 역할을 이해하기

> 파라미터는 함수에 입력값을 전달하기 위한 수단이다.
>
> 마치 주방장이 요리할 때 **재료**가 필요하듯, 함수도 필요한 값이 있으면 파라미터로 받아서 일을 한다.
>
> **함수 선언 시에 파라미터를 정의**하고, **함수 호출 시에 실제 값을 전달**한다. 이렇게 하면 함수는 **고정된 값에만 의존하지 않고** 어떤 재료가 들어오든 맞춰서 **요리(작동)**할 수 있게 됨.

### 함수에서 여러 개의 파라미터 사용하기

간단한 또 다른 예로, 두 숫자를 더하는 함수를 만들어보면. **파라미터**로 **두 개의 숫자**를 받아 그 합을 출력하게 할 수 있다.

```jsx
// 두 개의 숫자를 받아서 더한 결과를 출력하는 함수
function printSum(a, b) {
  console.log(a + b);
}

// 함수 호출
printSum(10, 5); // 15
printSum(7, 3); // 10
```

이 함수에서는 `a`와 `b`라는 두 개의 **파라미터**를 사용한다. 함수가 호출될 때 `a`와 `b`에는 각각 10과 5, 7과 3이 전달된다.

**전달된 값들은 함수 내부에서 변수처럼 사용되며**, 그 합을 출력한다.

### 파라미터 이름의 중요성

**파라미터** 이름을 의미 있게 짓는 것이 중요하다. 단순히 `a`, `b`와 같은 이름 대신, 해당 값이 어떤 의미를 갖는지 알 수 있도록 **의미 있는 이름**을 사용하는 것이 좋다. 예를 들어, 숫자를 더하는 함수에서는 `num1`, `num2`와 같은 이름을 사용하면 훨씬 알아보기 쉽다.

```jsx
// 두 개의 숫자를 받아서 더한 결과를 출력하는 함수
function printSum(num1, num2) {
  console.log(num1 + num2);
}

// 함수 호출
printSum(10, 5); // 15
```

이처럼 **파라미터** 이름을 적절하게 지정하면 함수의 역할이 한눈에 들어온다. 코드 **가독성**도 좋아져서, 나중에 코드가 복잡해지더라도 쉽게 이해할 수 있다.

### 여러 개의 파라미터 사용

함수는 여러 개의 **파라미터**를 받을 수 있지만, 너무 많이 쓰면 *"나 다 받으려고 만든 함수임"* 하고 욕심을 부리는 것 같아질 수 있다. 필요한 **파라미터**만 적절히 사용하는 게 좋다.

아래 예시는 **이름, 생년월일, 국적, 직업**을 파라미터로 받아서 출력하는 함수이다.

```jsx
// **이름, 생년월일, 국적, 직업**을 파라미터로 받아서 출력하는 함수
function introduce(name, birthDate, nationality, job) {
  console.log("안녕하세요! 제 이름은 " + name + "입니다.");
  console.log("저는 " + birthDate + "에 태어났어요.");
  console.log("국적은 " + nationality + "이고,");
  console.log("현재 직업은 " + job + "입니다.");
}

// 함수 호출: 자기 소개 예시
introduce("홍길동", "1990-01-01", "한국", "개발자");

// 또 다른 자기 소개 예시
introduce("김영희", "1985-05-15", "미국", "디자이너");
```

```
// 출력결과
안녕하세요! 제 이름은 홍길동입니다.
저는 1990-01-01에 태어났어요.
국적은 한국이고,
현재 직업은 개발자입니다.

안녕하세요! 제 이름은 김영희입니다.
저는 1985-05-15에 태어났어요.
국적은 미국이고,
현재 직업은 디자이너입니다.
```

이 예시에서 함수의 **파라미터** 이름을 잘 정의해두면 함수의 목적을 명확하게 전달할 수 있고, 나중에 함수의 역할을 이해하기 쉽다.

## 파라미터 활용의 장점

**파라미터**는 함수를 **더 유연하게** 만들어 주는 마법 같은 존재다. 단순히 고정된 동작을 하는 함수가 아니라, **입력값에 따라 다르게 작동**할 수 있는 멀티플레이어로 만들 수 있다. 덕분에 함수는 다양한 상황에 맞게 **재사용**할 수 있으며, 코드는 **간결하고 효율적**으로 변신한다.

예를 들어, 숫자의 제곱을 계산하는 함수를 만들어보자. 이 함수는 입력받은 숫자를 제곱한 결과를 출력한다.

```jsx
// 숫자를 받아 그 제곱을 출력하는 함수
function square(x) {
  console.log(x * x);
}

square(3); // 출력: 9
square(5); // 출력: 25
square(10); // 출력: 100
```

이 함수는 **파라미터** `x`로 전달된 값을 제곱해서 출력한다. 덕분에 원하는 숫자를 넣기만 하면 바로 제곱값을 얻을 수 있다.

이렇게 다양한 숫자에 대해 자유롭게 제곱을 계산할 수 있으니, 함수가 마치 만능 계산기로 업그레이드된 느낌이다.

> 정리
>
> `파라미터`는 함수가 외부로부터 `입력값`을 받아 처리할 수 있게 해주는 역할을 한다. 덕분에 하나의 함수로 다양한 상황을 처리할 수 있으며, 고정된 값에만 의존하지 않는 **유연하고 재사용 가능한 코드**를 만들 수 있다.

# 리턴(return)

# 함수와 리턴(return)

> 함수? 수학 시간에 봤던 복잡한 좌표나 숫자 떠오르지만, 사실 함수는 생각보다 단순하다.
>
> 함수는 일종의 **상자**로 생각하면 편하다.
>
> 이 상자에 **입력값(input)**이 들어가고, 상자 안에서 어떤 작업이 이루어진 후 **출력값(output)**이 나오게 된다.

## 리턴(return) - 값을 돌려준다

!https://velog.velcdn.com/images/moon_dev/post/00ecb032-99a9-48c0-a3de-40cc0a368196/image.jpeg

자바스크립트에서 함수는 일을 다 하고 나면 **`return` 키워드**를 사용해 값을 돌려준다.

이때 `return`된 값은 호출한 자리로 슝~하고 돌아가는데, 마치 “일은 내가 했으니 알아서 써라” 하고 내던지는 느낌이다.

> return된 값은 편지의 답장이 온 것처럼 함수 호출 위치로 “전달”된다.

### **리턴(return)**의 기본 예시

아래는 `get7()` 함수가 숫자 7을 반환하는 예시다.

```jsx
// get7 함수 선언
function get7() {
  // return: 함수가 실행된 후, 값 7을 return(돌려줌)
  // return된 값은 함수 호출한 자리로 전달됨
  return 7;
}

// get7() 함수 호출: 함수가 호출되면 return값 7이 반환되고,
// 이 값은 console.log에 전달되어 출력됨
console.log(get7()); // 출력: 7
```

이 함수는 호출되면 무조건 7을 반환한다. `return`된 값은 함수가 호출된 자리로 돌아가서 `console.log()`에 전달되어 출력된다.

> 쉽게 말해, 함수는 계산한 결과값을 외부로 전달하는 역할을 한다.

### 파라미터가 있는 함수에서의 **리턴(return)**

함수는 외부에서 **파라미터**를 받아서 그 값을 처리한 후 결과를 **`return`**할 수도 있다.

예를 들어, 어떤 숫자를 받아서 그 숫자의 두 배를 돌려주는 함수를 만들어 보자.

```jsx
// getTwice 함수: 입력된 숫자의 두 배를 return함
function getTwice(number) {
  return number * 2; // 입력된 값 * 2를 return
}

// 함수 호출: 5를 전달하면 10이 return되고 출력됨
console.log(getTwice(5)); // 출력: 10
```

여기서 숫자 **5**가 파라미터로 전달되면, 함수는 **5**의 두 배인 **10**을 반환한다. **파라미터** 덕분에 입력 **값**을 자유롭게 조정해 원하는 결과를 얻을 수 있다.

> 생각해보기: 그럼 getTwice(3.5)는 어떤 결과를 줄까? 직접 테스트해보면 파라미터와 return의 관계를 더 쉽게 이해할 수 있을 것이다.
>
> 이 함수는 마치 “요청하신 두 배, 바로 나갑니다!” 하고 바로 돌려주는 친절한 계산기 같은 존재!

### 리턴(return)을 변수에 저장하기

함수의 `return`값은 변수에 저장할 수 있으며, 이를 다른 연산에 사용할 수 있다.

예를 들어, 두 개의 값을 받아서 각각의 결과를 곱하는 예시를 살펴보자.

```jsx
let x = getTwice(5); // x에는 10이 저장됨
let y = getTwice(2); // y에는 4가 저장됨

console.log(x * y); // 출력: 40
```

이 코드에서 **x**에는 10, **y**에는 **4**가 저장되고, x \* y를 계산하면 **40**이 출력된다. 이렇게 `return`값을 **변수**에 저장해 두면, 다른 계산이나 로직에서 재활용할 수 있어 **함수의 활용도**가 훨씬 높아진다.

---

## 실습 문제: 주식 수익 계산기 함수 만들기

문제 설명: 사회초년생 지훈이 매수한 주식의 매수 금액, 매도 금액, 보유 주식 수를 바탕으로 총 수익을 계산하고 싶어 한다. 공식은 간단하다:

> 총 수익 = (매도 금액 - 매수 금액) × 보유 주식 수

**구현할 함수**: `stockProfitCalculator` 함수는 매수 금액, 매도 금액, 보유 주식 수를 입력받아 총 수익을 계산한다.

### 문제 예시 코드

```jsx
// 주식 수익을 계산해주는 함수 작성
// 여기에 코드를 작성하세요

// 조건 입력 테스트
let buyPrice = 50000; // 주식을 매수한 금액 (1주당)
let sellPrice = 60000; // 주식을 매도한 금액 (1주당)
let numberOfShares = 10; // 보유 주식 수

// 수익 계산 후 출력
let totalProfit = stockProfitCalculator(buyPrice, sellPrice, numberOfShares);
console.log("총 수익은 " + totalProfit + "원 입니다.");
```

---

### 답안 코드

```jsx
// 주식 수익을 계산해주는 함수
function stockProfitCalculator(buyPrice, sellPrice, numberOfShares) {
  return (sellPrice - buyPrice) * numberOfShares; // 수익 계산 후 return
}

// 조건 입력 테스트
let buyPrice = 50000; // 주식을 매수한 금액 (1주당)
let sellPrice = 60000; // 주식을 매도한 금액 (1주당)
let numberOfShares = 10; // 보유 주식 수

// 총 수익 계산 후 출력
let totalProfit = stockProfitCalculator(buyPrice, sellPrice, numberOfShares);
console.log("총 수익은 " + totalProfit + "원 입니다.");
```

**출력 결과**:

```
총 수익은 100000원 입니다.
```

---

## 리턴(return)값의 활용

함수의 `return` 값은 단순히 출력하는 데 그치지 않고, 변수에 저장하거나 다른 함수의 입력값으로 활용할 수도 있다. 이렇게 하면 여러 함수의 결과를 연결해서 복잡한 작업도 간단하게 처리할 수 있다. 함수의 모듈화를 통해 유연하고 효율적인 코드를 작성할 수 있게 된다.

> return값을 통해 함수가 처리한 결과를 외부로 전달하는 방식은 프로그래밍에서 매우 중요한 개념이다.
>
> `return`을 사용하면 함수의 결과를 변수에 저장하거나, 다른 계산에 활용할 수 있어 함수의 유연성이 크게 향상된다.
>
> 함수는 단순한 작업을 반복적으로 처리하는 데 매우 유용한 도구로, 특히 `return`값을 적절히 활용하면 훨씬 다양한 방식으로 함수를 활용할 수 있다.

# 함수의 실행 순서, 리턴문 완벽 이해, 그리고 console.log()와의 차이

## 함수의 실행 순서

> 자바스크립트에서는 코드를 위에서 아래로 한 줄씩 차례대로 실행한다. 하지만 함수가 호출되면 실행 흐름이 잠시 멈추고, 함수 내부의 코드가 먼저 실행된다. 그런 다음 다시 원래 위치로 돌아와 남은 코드를 계속 실행하게 된다.

---

### 함수 정의와 실행 순서

다음 코드를 통해 함수 호출과 실행 순서를 살펴보자:

```jsx
function sayHello() {
  console.log("Hello");
  console.log("Welcome to JavaScript!");
}

console.log("Before function call"); // 1
sayHello(); // 2: 함수 호출
console.log("After function call"); // 3
```

이 코드가 실행되면 다음과 같은 흐름으로 진행된다:

1. **1번 줄**에서 `"Before function call"`이 출력된다.
2. **2번 줄**에서 `sayHello()` 함수가 호출된다. 그러면 함수 내부의 코드가 실행된다:
   - `"Hello"`가 출력된다.
   - `"Welcome to JavaScript!"`가 출력된다.
3. 함수가 끝난 후 **3번 줄**로 돌아와 `"After function call"`이 출력된다.

결과적으로 출력 순서는 다음과 같다:

```
Before function call
Hello
Welcome to JavaScript!
After function call

```

이때 중요한 점은 **함수가 호출되면 코드의 실행 흐름이 함수 내부로 이동**했다가, 함수 실행이 끝나면 다시 호출된 위치로 돌아와 **남은 코드**가 실행된다는 것이다.

---

### 파라미터와 리턴값이 있는 함수

함수는 **파라미터**를 통해 값을 전달받고, 그 값을 **연산하여 리턴**할 수 있다. 이번에는 함수에 파라미터를 전달하고, 함수가 **리턴값**을 돌려주는 과정을 살펴보자.

```jsx
function square(x) {
  return x * x; // 리턴문: x의 제곱 값을 돌려줌
}

console.log("Before square function call"); // 1
console.log(square(5)); // 2: 25 출력
console.log("After square function call"); // 3
```

이 코드는 다음과 같은 흐름으로 실행된다:

1. **1번 줄**에서 `"Before square function call"`이 출력된다.
2. **2번 줄**에서 `square(5)`가 호출된다. 이때, **파라미터로 5**가 전달되어 함수 내부에서 `5 * 5`가 계산된다.
3. **리턴문**을 통해 계산 결과인 **25**가 함수 호출 부분으로 돌려진다.
4. `console.log(square(5))`는 **25**를 출력하고, 함수는 끝난다.
5. 다시 원래 위치로 돌아와 **3번 줄**에서 `"After square function call"`이 출력된다.

결과적으로 출력 순서는:

```
Before square function call
25
After square function call

```

---

### 리턴값을 이용한 함수 호출

함수는 여러 번 호출될 수 있으며, 리턴된 값은 다른 연산에 사용될 수 있다. 이제 함수가 호출되고, 리턴값이 또 다른 계산에 사용되는 경우를 살펴보자.

```jsx
function square(x) {
  return x * x;
}

console.log(square(3) + square(4)); // 9 + 16 = 25 출력
```

이 코드의 실행 순서는 다음과 같다:

1. 먼저 `square(3)`이 호출되고, **9**가 리턴된다.
2. 그다음 `square(4)`가 호출되고, **16**이 리턴된다.
3. 마지막으로 `9 + 16`이 계산되어 **25**가 출력된다.

## 함수의 실행 순서 요약

- **함수 호출과 실행 순서**: 함수가 호출되면 함수 내부의 코드가 먼저 실행되고, 함수가 끝난 후 다시 호출된 위치로 돌아가 남은 코드가 실행된다.

---

## return문 제대로 이해하기

> 자바스크립트에서 리턴문(return)은 함수의 실행 결과를 호출한 곳으로 되돌려주는 역할을 한다. 리턴은 단순히 값을 반환하는 것 외에도 함수의 실행을 중단시키는 중요한 역할을 한다. 이번에는 리턴문의 두 가지 역할과 이를 활용한 예제를 살펴보자.

---

### 리턴값을 돌려주는 역할

리턴문은 **함수에서 계산된 결과값을 돌려주는 역할**을 한다. 예를 들어, 숫자를 제곱하는 함수에서 리턴문을 사용하여 연산 결과를 반환할 수 있다.

### 예시: 리턴문을 사용한 함수

```jsx
function square(x) {
  return x * x;
}

console.log(square(3)); // 9 출력
```

위 코드를 보면, `square(3)`이 호출되면서 **3이 파라미터로 전달**되고, 함수는 **3의 제곱인 9**를 리턴한다. 따라서 `console.log(square(3))`은 **9**를 출력하게 된다.

---

### 리턴문을 통한 함수 실행 중단

리턴문은 값을 돌려주는 역할 외에도, **함수의 실행을 중단**하는 기능을 한다. 리턴문을 만나면 그 아래에 작성된 코드는 **절대로 실행되지 않는다**.

### 예시: 리턴문 이후의 코드가 실행되지 않음

```jsx
function example() {
  console.log("리턴문 이전 출력");
  return 42;
  console.log("이 코드는 실행되지 않습니다"); // 이 코드는 실행되지 않음
}

console.log(example()); // "리턴문 이전 출력" 후 42 리턴
```

이 코드에서 **"리턴문 이전 출력"**은 정상적으로 출력되지만, 리턴문 뒤의 **"이 코드는 실행되지 않습니다"**는 실행되지 않는다. **리턴문**은 값을 돌려주는 동시에 **함수가 즉시 종료**되기 때문이다.

---

### 리턴문과 데드 코드(Dead Code)

리턴문 뒤에 작성된 코드는 **절대로 실행되지 않기 때문에 의미가 없다**. 이런 코드를 **데드 코드(Dead Code)**라고 부른다. 함수 내에서 리턴문 이후의 코드는 더 이상 실행될 가능성이 없으므로, **작성하지 않는 것이 좋다**.

### 예시: 데드 코드

```jsx
function deadCodeExample() {
  console.log("이 코드는 실행됩니다");
  return;
  console.log("이 코드는 절대 실행되지 않습니다"); // 데드 코드
}

deadCodeExample(); // "이 코드는 실행됩니다"만 출력
```

위 코드에서 **"이 코드는 실행됩니다"**는 출력되지만, **리턴문 뒤의 코드**는 실행되지 않는다. 이런 코드는 **데드 코드**가 되어 불필요한 코드로 남게 된다.

---

### 리턴문의 실행 순서

함수의 실행 순서와 리턴문이 함수 실행을 중단하는 과정을 좀 더 자세히 살펴보자.

### 예시: 리턴문을 통한 함수 흐름 중단

```jsx
function squareWithLogs(x) {
  console.log("리턴문 이전 출력");
  return x * x; // 리턴으로 값이 반환되고 함수가 종료됨
  console.log("리턴문 이후 출력"); // 이 코드는 실행되지 않음
}

console.log(squareWithLogs(3)); // "리턴문 이전 출력" 후 9 리턴
```

이 코드를 실행하면 다음과 같은 순서로 동작한다:

1. "리턴문 이전 출력"\*\*이 출력된다.
2. 그다음 **`x * x`가 계산되어** 9\*\*가 리턴된다.
3. 리턴문을 만나면 함수가 즉시 종료되므로, **"리턴문 이후 출력"**은 출력되지 않는다.

---

## return문 제대로 이해하기 요약

> 리턴문의 첫 번째 역할: 값을 함수 호출 부분으로 돌려준다.리턴문의 두 번째 역할: 함수를 즉시 종료하고, 리턴문 이후의 코드는 실행되지 않는다.데드 코드(Dead Code): 리턴문 뒤에 있는 코드는 실행되지 않기 때문에 의미가 없으며, 이를 데드 코드라고 부른다.

> 리턴문은 단순한 값 반환 외에도 함수의 흐름을 제어하는 중요한 역할을 한다. 함수를 작성할 때 리턴문의 두 가지 역할을 명확히 이해하고, 리턴문 이후에 불필요한 코드를 작성하지 않도록 주의해야한다.

---

## `return`과 `console.log()`의 차이

> 처음 자바스크립트를 공부할 때, 많은 사람들이 리턴문(return)과 console.log()를 헷갈리는 경우가 많다. 둘 다 함수에서 중요한 역할을 하지만, 그 역할이 서로 다르다. 이번에는 리턴문과 console.log()가 각각 어떤 역할을 하는지, 그리고 둘의 차이를 예제와 함께 알아보자.

---

### 리턴과 `console.log()`의 역할

- **리턴문**: 함수의 실행 결과를 돌려주는 역할을 한다. 리턴된 값은 함수 호출 부분에서 사용할 수 있다.
- **`console.log()`**: 특정 값을 **콘솔에 출력**하는 역할을 한다. 값을 단순히 보여주는 용도로 사용된다.

이 차이를 구체적인 예제와 함께 살펴보자.

---

### `console.log()`로 출력하는 함수

먼저, **`console.log()`**를 이용해 결과를 출력하는 함수 `printSquare`를 정의해보자. 이 함수는 **입력받은 값을 제곱**한 결과를 **출력**하는 역할을 한다.

```jsx
function printSquare(x) {
  console.log(x * x); // 제곱한 값을 출력함
}

printSquare(3); // 9 출력
```

이 함수는 **리턴값이 없고**, 단순히 **콘솔에 결과를 출력**하기만 한다. `printSquare(3)`을 호출하면 콘솔에 **3의 제곱인 9**가 출력된다. 하지만 함수 자체는 **값을 돌려주지 않는다**.

---

### 리턴값을 돌려주는 함수

이번에는, **리턴문**을 사용해 계산 결과를 함수 호출한 곳으로 **돌려주는 함수**를 정의해보자. 이 함수는 결과를 출력하지 않고, **계산된 값을 리턴**한다.

```jsx
function getSquare(x) {
  return x * x; // 제곱한 값을 리턴함
}

console.log(getSquare(3)); // 9 출력
```

`getSquare(3)` 함수는 **3의 제곱인 9를 리턴**한다. `console.log()`를 사용해 리턴된 값을 **출력**하면, 9가 출력된다.

이 함수는 **값을 돌려줄 뿐, 그 값을 바로 출력하지는 않는다**. 따라서 출력하고 싶다면 반드시 **`console.log()`**나 다른 출력 방법을 사용해야 한다.

---

### 리턴 없는 함수는 `undefined`를 리턴

함수에 **리턴문이 없을 경우**, 자바스크립트는 자동으로 **`undefined`**를 리턴한다. 이를 잘못 이해하면 의도하지 않은 결과를 얻을 수 있다.

### 예시: 리턴문이 없는 함수 호출

```jsx
function printSquare(x) {
  console.log(x * x); // 제곱한 값을 출력
}

console.log(printSquare(3)); // 9 출력 후 undefined 출력
```

위 코드에서 **`printSquare(3)`**는 9를 출력하지만, 함수 자체는 **리턴값이 없기 때문에** `undefined`를 리턴한다. 그래서 **`console.log(printSquare(3))`**를 실행하면 **9**와 **`undefined`**가 함께 출력된다.

- **9**는 함수 내부에서 출력된 값이고,
- `*undefined*`는 함수가 값을 리턴하지 않았기 때문에 자동으로 반환된 값이다.

---

### 리턴된 값으로 다른 연산 수행

리턴된 값은 다른 연산에 사용할 수 있다. 예를 들어, **리턴된 값을 바로 출력**하거나 **다른 계산**에 사용할 수 있다.

```jsx
console.log(getSquare(3) + getSquare(4)); // 9 + 16 = 25 출력
```

이 코드에서는 `getSquare(3)`가 **9**를 리턴하고, `getSquare(4)`가 **16**을 리턴하여, 두 값을 더한 **25**가 출력된다.

---

### `console.log()`로 감싸지 않으면 아무것도 출력되지 않음

리턴문이 있는 함수는 값을 돌려줄 뿐, **출력하지는 않는다**. 출력하려면 **`console.log()`**로 감싸야 한다.

### 예시: 출력되지 않는 리턴값

```jsx
function getSquare(x) {
  return x * x;
}

getSquare(3); // 출력 없음
```

이 코드는 **출력되지 않는다**. 리턴값은 있지만, 그 값을 **출력**하려면 별도의 **`console.log()`**를 사용해야 한다.

---

## `return`과 `console.log()`의 차이 요약

> 리턴문: 함수를 실행한 후 값을 돌려주는 역할을 한다. 하지만 리턴된 값은 별도로 출력되지 않으며, 그 값을 출력하려면 console.log() 같은 함수로 감싸야 한다.console.log(): 값을 출력하는 함수로, 계산된 값을 콘솔에 보여주는 용도로 사용된다.리턴문이 없는 함수는 자동으로 \*undefined를 리턴하며, 이를 주의해야 한다.

리턴과 `console.log()`의 차이를 명확히 구분하면, 함수를 작성할 때 더 **의도에 맞는 코드**를 작성할 수 있다.

# 옵셔널 파라미터 (Optional Parameters)

### 파라미터와 옵셔널 파라미터 이해하기

> 함수를 호출할 때 파라미터를 활용하면, 입력받은 값에 따라 다양한 결괏값을 얻을 수 있다. 함수에 전달하는 값은 상황에 따라 달라질 수 있기 때문에, 파라미터를 통해 유동적으로 처리할 수 있다.

그렇다면, **파라미터가 있는 함수에 아무 값도 전달하지 않으면** 어떻게 될까?

---

### 파라미터가 없는 경우의 동작

파라미터가 있는 함수에 값을 전달하지 않고 호출하면, 자바스크립트에서는 해당 파라미터가 **`undefined`** 값을 받게 된다.

### 예시

```jsx
function greet(name) {
  console.log("Hello, " + name);
}

greet(); // Hello, undefined 출력
```

위 코드를 보면, 함수 `greet`는 파라미터 `name`을 받지만, 호출할 때 아무 값도 전달하지 않았다. 이때, `name`은 자동으로 **`undefined`** 값을 받게 된다. 그래서 **`Hello, undefined`**라는 결과가 출력된다.

---

### `undefined`가 나오는 다른 상황들

`undefined`가 나오는 상황은 몇 가지가 더 있다. 예를 들어, 변수를 선언만 하고 **아무 값도 할당하지 않았을 때**, 또는 함수에 **리턴문이 없을 때**도 `undefined`가 출력된다.

### 예시: 리턴문이 없는 경우

```jsx
function sayHello() {
  console.log("Hello");
}

console.log(sayHello()); // "Hello" 출력 후, undefined 출력
```

위 코드에서 **`sayHello`** 함수는 값을 리턴하지 않으므로, 호출한 결과는 자동으로 **`undefined`**가 된다. 이처럼 **리턴값이 없는 함수**도 호출할 때 `undefined`를 돌려준다.

---

### 옵셔널 파라미터 (Optional Parameters)

파라미터가 **필수값**은 아니고, 경우에 따라 **기본값**을 설정해 둘 수 있다. 이렇게 하면, 값을 전달하지 않아도 **기본값**이 자동으로 사용된다. 이를 **옵셔널 파라미터 (Optional Parameters)** 라고 부른다. 즉, 값을 전달하지 않으면 **미리 설정된 기본값**을 사용한다.

### 예시: 기본값이 설정된 파라미터

```jsx
function greet(name = "친구") {
  console.log("Hello, " + name);
}

greet(); // Hello, 친구 출력
greet("코딩"); // Hello, 코딩 출력
```

여기서 함수 `greet`는 파라미터 `name`에 기본값으로 **"친구"**를 설정했다. 따라서 호출 시에 **값을 전달하지 않으면** 기본값이 사용되어 **`Hello, 친구`**가 출력된다. 값을 전달할 경우에는 **전달한 값**을 사용하여 결과가 출력된다.

---

### 옵셔널 파라미터의 위치

옵셔널 파라미터는 **가장 뒤에 위치**해야 한다. 파라미터의 순서가 뒤죽박죽이면, 함수 호출 시 값이 제대로 전달되지 않거나 **`undefined`** 값이 생길 수 있다. 특히, 중간에 기본값이 설정된 파라미터가 있으면 **전달 순서가 꼬일 수 있다.**

### 잘못된 예시

```jsx
function introduce(name, age = 25, city) {
  console.log(name + "는 " + age + "살이고 " + city + "에 삽니다.");
}

introduce("철수", "서울"); // 철수는 서울살이고 undefined에 삽니다.
```

위 코드에서는 `age`에 기본값을 설정했지만, **중간에 위치**해 있어서 함수 호출 시 **순서가 밀리게 된다.** 그래서 `age`에 "서울"이 전달되고, `city`는 **`undefined`**가 되어 결과가 엉망이 된다.

### 올바른 예시

```jsx
function introduce(name, city, age = 25) {
  console.log(name + "는 " + age + "살이고 " + city + "에 삽니다.");
}

introduce("철수", "서울"); // 철수는 25살이고 서울에 삽니다.
```

이렇게 **옵셔널 파라미터는 뒤에 위치**시켜야, 생략하더라도 문제가 생기지 않는다. 값이 제대로 전달되어 함수가 의도대로 동작한다.

---

### 요약

> 파라미터: 함수를 호출할 때 전달받는 값으로, 다양한 결과를 만들 수 있다.값이 전달되지 않으면 undefined가 출력되며, 변수를 선언만 했을 때나 리턴문이 없는 함수에서도 undefined가 발생한다.옵셔널 파라미터: 파라미터에 기본값을 설정하여, 값을 생략해도 기본값이 자동으로 사용되게 한다.옵셔널 파라미터는 가장 뒤에 위치해야 순서가 꼬이지 않고 올바르게 동작한다.

파라미터와 옵셔널 파라미터를 잘 활용하면, 함수 호출 시 값이 전달되지 않거나 생략되었을 때도 안정적으로 동작하는 코드를 작성할 수 있다!
