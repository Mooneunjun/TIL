# 파라미터(parameter)

## **파라미터**(parameter)란 무엇인가?

**파라미터**는 함수에 **입력으로 전달되는 값**을 받기 위한 변수다. 함수를 선언할 때 **소괄호 안에 작성**되는 것이 바로 파라미터다.

이 파라미터는 **함수가 호출될 때** 전달되는 값을 받아, 함수 내부에서 그 값을 **변수처럼** 사용할 수 있다.

```jsx
//함수 선언
function 함수이름(파라미터) {
  // 매개변수 = 파라미터(parameter)
  console.log(파라미터);
}

//함수 호출
함수이름(값); // 값 = 인자(argument)
```

예를들면 **배달** 갈 때 "**여기 치킨 한 마리 배달 좀 해주세요**" 이렇게 주문을 받잖아? 여기서 '**치킨**` 한 마리가 **함수**한테 주어진 **파라미터** 같은 거임. 함수는 "_아~ 치킨? 오케이!_" 하면서 그걸 받아서 처리함.

```jsx
// 함수 선언
function 배달(물건) {
  // '물건'이 파라미터
  console.log(물건 + " 배달 완료!");
}

// 함수 호출
배달("치킨"); // 여기가 인자(치킨) 전달하는 부분!

//console.log 출력: 치킨 배달 완료!
```

위 코드에서, `물건`은 **파라미터**이고 `치킨`은 **인자**다. 파라미터는 "내가 무엇이든 받을 준비가 되어있다!"라는 입장이고, 인자는 실제로 전달된 값을 의미한다.

!https://velog.velcdn.com/images/moon_dev/post/7fe2ccd0-f023-4b24-ac0b-d21e7bc21a5e/image.png

요약하자면:

**`파라미터`**는 그냥 함수가 일단 받아둘 자리 표시.

**`인자`**는 함수에 진짜로 넘겨주는 값.

> 그래서 이게 진짜 좋은 게 뭐냐면, 함수를 한 번 만들어 두면 치킨만이 아니라 피자, 햄버거… 뭐든지 배달 시킬 수 있다는 거임. 유연하다고! 👀

### 파라미터의 개념 예시

파라미터를 사용하면 하나의 함수로 여러 상황을 유연하게 처리할 수 있다. 예를 들어, 인사말을 출력하는 함수를 생각해보자. **파라미터 없이 작성한 함수**는 고정된 메시지만 출력한다.

```jsx
// 파라미터 없이 고정된 인사말 출력
function greet() {
  console.log("Hello, John!");
}

greet(); // 출력: Hello, John!
```

이 함수는 무조건 'Hello, John!'이라고만 인사말을 출력한다. 그러나 **파라미터**를 사용하면 이름을 **유동적**으로 바꿔가며 인사를 할 수 있게 된다.

**파라미터**를 사용하면, 함수를 호출할 때마다 **다른 값을 전달**할 수 있다. 이를 통해 함수는 입력에 따라 **다양한 동작**을 할 수 있게 된다. 다음은 이름을 파라미터로 받아서 **유동적인 인사말**을 출력하는 함수의 예시다.

```jsx
// 파라미터로 이름을 받아서 인사말 출력
function greet(name) {
  console.log("Hello, " + name + "!");
}

greet("Alice"); // 출력: Hello, Alice!
greet("Bob"); // 출력: Hello, Bob!
```

여기서 `name`이라는 **파라미터**가 등장한다. 이 파라미터는 함수를 호출할 때 **소괄호 안에 전달된 값**을 받는다.

`greet('Alice')`를 호출하면, 'Alice'라는 값이 `name`**파라미터**로 전달되어 **`console.log()`** 내부에서 사용된다. 이렇게 **파라미터**를 활용하면, 함수를 더 **유연하게** 사용할 수 있다.

## 파라미터의 역할을 이해하기

> 파라미터는 함수에 입력값을 전달하기 위한 수단이다.
>
> 마치 주방장이 요리할 때 **재료**가 필요하듯, 함수도 필요한 값이 있으면 파라미터로 받아서 일을 한다.
>
> **함수 선언 시에 파라미터를 정의**하고, **함수 호출 시에 실제 값을 전달**한다. 이렇게 하면 함수는 **고정된 값에만 의존하지 않고** 어떤 재료가 들어오든 맞춰서 **요리(작동)**할 수 있게 됨.

### 함수에서 여러 개의 파라미터 사용하기

간단한 또 다른 예로, 두 숫자를 더하는 함수를 만들어보면. **파라미터**로 **두 개의 숫자**를 받아 그 합을 출력하게 할 수 있다.

```jsx
// 두 개의 숫자를 받아서 더한 결과를 출력하는 함수
function printSum(a, b) {
  console.log(a + b);
}

// 함수 호출
printSum(10, 5); // 15
printSum(7, 3); // 10
```

이 함수에서는 `a`와 `b`라는 두 개의 **파라미터**를 사용한다. 함수가 호출될 때 `a`와 `b`에는 각각 10과 5, 7과 3이 전달된다.

**전달된 값들은 함수 내부에서 변수처럼 사용되며**, 그 합을 출력한다.

### 파라미터 이름의 중요성

**파라미터** 이름을 의미 있게 짓는 것이 중요하다. 단순히 `a`, `b`와 같은 이름 대신, 해당 값이 어떤 의미를 갖는지 알 수 있도록 **의미 있는 이름**을 사용하는 것이 좋다. 예를 들어, 숫자를 더하는 함수에서는 `num1`, `num2`와 같은 이름을 사용하면 훨씬 알아보기 쉽다.

```jsx
// 두 개의 숫자를 받아서 더한 결과를 출력하는 함수
function printSum(num1, num2) {
  console.log(num1 + num2);
}

// 함수 호출
printSum(10, 5); // 15
```

이처럼 **파라미터** 이름을 적절하게 지정하면 함수의 역할이 한눈에 들어온다. 코드 **가독성**도 좋아져서, 나중에 코드가 복잡해지더라도 쉽게 이해할 수 있다.

### 여러 개의 파라미터 사용

함수는 여러 개의 **파라미터**를 받을 수 있지만, 너무 많이 쓰면 *"나 다 받으려고 만든 함수임"* 하고 욕심을 부리는 것 같아질 수 있다. 필요한 **파라미터**만 적절히 사용하는 게 좋다.

아래 예시는 **이름, 생년월일, 국적, 직업**을 파라미터로 받아서 출력하는 함수이다.

```jsx
// **이름, 생년월일, 국적, 직업**을 파라미터로 받아서 출력하는 함수
function introduce(name, birthDate, nationality, job) {
  console.log("안녕하세요! 제 이름은 " + name + "입니다.");
  console.log("저는 " + birthDate + "에 태어났어요.");
  console.log("국적은 " + nationality + "이고,");
  console.log("현재 직업은 " + job + "입니다.");
}

// 함수 호출: 자기 소개 예시
introduce("홍길동", "1990-01-01", "한국", "개발자");

// 또 다른 자기 소개 예시
introduce("김영희", "1985-05-15", "미국", "디자이너");
```

```
// 출력결과
안녕하세요! 제 이름은 홍길동입니다.
저는 1990-01-01에 태어났어요.
국적은 한국이고,
현재 직업은 개발자입니다.

안녕하세요! 제 이름은 김영희입니다.
저는 1985-05-15에 태어났어요.
국적은 미국이고,
현재 직업은 디자이너입니다.
```

이 예시에서 함수의 **파라미터** 이름을 잘 정의해두면 함수의 목적을 명확하게 전달할 수 있고, 나중에 함수의 역할을 이해하기 쉽다.

## 파라미터 활용의 장점

**파라미터**는 함수를 **더 유연하게** 만들어 주는 마법 같은 존재다. 단순히 고정된 동작을 하는 함수가 아니라, **입력값에 따라 다르게 작동**할 수 있는 멀티플레이어로 만들 수 있다. 덕분에 함수는 다양한 상황에 맞게 **재사용**할 수 있으며, 코드는 **간결하고 효율적**으로 변신한다.

예를 들어, 숫자의 제곱을 계산하는 함수를 만들어보자. 이 함수는 입력받은 숫자를 제곱한 결과를 출력한다.

```jsx
// 숫자를 받아 그 제곱을 출력하는 함수
function square(x) {
  console.log(x * x);
}

square(3); // 출력: 9
square(5); // 출력: 25
square(10); // 출력: 100
```

이 함수는 **파라미터** `x`로 전달된 값을 제곱해서 출력한다. 덕분에 원하는 숫자를 넣기만 하면 바로 제곱값을 얻을 수 있다.

이렇게 다양한 숫자에 대해 자유롭게 제곱을 계산할 수 있으니, 함수가 마치 만능 계산기로 업그레이드된 느낌이다.

> 정리
>
> `파라미터`는 함수가 외부로부터 `입력값`을 받아 처리할 수 있게 해주는 역할을 한다. 덕분에 하나의 함수로 다양한 상황을 처리할 수 있으며, 고정된 값에만 의존하지 않는 **유연하고 재사용 가능한 코드**를 만들 수 있다.

# 옵셔널 파라미터 (Optional Parameters)

### 파라미터와 옵셔널 파라미터 이해하기

> 함수를 호출할 때 파라미터를 활용하면, 입력받은 값에 따라 다양한 결괏값을 얻을 수 있다. 함수에 전달하는 값은 상황에 따라 달라질 수 있기 때문에, 파라미터를 통해 유동적으로 처리할 수 있다.

그렇다면, **파라미터가 있는 함수에 아무 값도 전달하지 않으면** 어떻게 될까?

---

### 파라미터가 없는 경우의 동작

파라미터가 있는 함수에 값을 전달하지 않고 호출하면, 자바스크립트에서는 해당 파라미터가 **`undefined`** 값을 받게 된다.

### 예시

```jsx
function greet(name) {
  console.log("Hello, " + name);
}

greet(); // Hello, undefined 출력
```

위 코드를 보면, 함수 `greet`는 파라미터 `name`을 받지만, 호출할 때 아무 값도 전달하지 않았다. 이때, `name`은 자동으로 **`undefined`** 값을 받게 된다. 그래서 **`Hello, undefined`**라는 결과가 출력된다.

---

### `undefined`가 나오는 다른 상황들

`undefined`가 나오는 상황은 몇 가지가 더 있다. 예를 들어, 변수를 선언만 하고 **아무 값도 할당하지 않았을 때**, 또는 함수에 **리턴문이 없을 때**도 `undefined`가 출력된다.

### 예시: 리턴문이 없는 경우

```jsx
function sayHello() {
  console.log("Hello");
}

console.log(sayHello()); // "Hello" 출력 후, undefined 출력
```

위 코드에서 **`sayHello`** 함수는 값을 리턴하지 않으므로, 호출한 결과는 자동으로 **`undefined`**가 된다. 이처럼 **리턴값이 없는 함수**도 호출할 때 `undefined`를 돌려준다.

---

### 옵셔널 파라미터 (Optional Parameters)

파라미터가 **필수값**은 아니고, 경우에 따라 **기본값**을 설정해 둘 수 있다. 이렇게 하면, 값을 전달하지 않아도 **기본값**이 자동으로 사용된다. 이를 **옵셔널 파라미터 (Optional Parameters)** 라고 부른다. 즉, 값을 전달하지 않으면 **미리 설정된 기본값**을 사용한다.

### 예시: 기본값이 설정된 파라미터

```jsx
function greet(name = "친구") {
  console.log("Hello, " + name);
}

greet(); // Hello, 친구 출력
greet("코딩"); // Hello, 코딩 출력
```

여기서 함수 `greet`는 파라미터 `name`에 기본값으로 **"친구"**를 설정했다. 따라서 호출 시에 **값을 전달하지 않으면** 기본값이 사용되어 **`Hello, 친구`**가 출력된다. 값을 전달할 경우에는 **전달한 값**을 사용하여 결과가 출력된다.

---

### 옵셔널 파라미터의 위치

옵셔널 파라미터는 **가장 뒤에 위치**해야 한다. 파라미터의 순서가 뒤죽박죽이면, 함수 호출 시 값이 제대로 전달되지 않거나 **`undefined`** 값이 생길 수 있다. 특히, 중간에 기본값이 설정된 파라미터가 있으면 **전달 순서가 꼬일 수 있다.**

### 잘못된 예시

```jsx
function introduce(name, age = 25, city) {
  console.log(name + "는 " + age + "살이고 " + city + "에 삽니다.");
}

introduce("철수", "서울"); // 철수는 서울살이고 undefined에 삽니다.
```

위 코드에서는 `age`에 기본값을 설정했지만, **중간에 위치**해 있어서 함수 호출 시 **순서가 밀리게 된다.** 그래서 `age`에 "서울"이 전달되고, `city`는 **`undefined`**가 되어 결과가 엉망이 된다.

### 올바른 예시

```jsx
function introduce(name, city, age = 25) {
  console.log(name + "는 " + age + "살이고 " + city + "에 삽니다.");
}

introduce("철수", "서울"); // 철수는 25살이고 서울에 삽니다.
```

이렇게 **옵셔널 파라미터는 뒤에 위치**시켜야, 생략하더라도 문제가 생기지 않는다. 값이 제대로 전달되어 함수가 의도대로 동작한다.

---

### 요약

> 파라미터: 함수를 호출할 때 전달받는 값으로, 다양한 결과를 만들 수 있다.값이 전달되지 않으면 undefined가 출력되며, 변수를 선언만 했을 때나 리턴문이 없는 함수에서도 undefined가 발생한다.옵셔널 파라미터: 파라미터에 기본값을 설정하여, 값을 생략해도 기본값이 자동으로 사용되게 한다.옵셔널 파라미터는 가장 뒤에 위치해야 순서가 꼬이지 않고 올바르게 동작한다.

파라미터와 옵셔널 파라미터를 잘 활용하면, 함수 호출 시 값이 전달되지 않거나 생략되었을 때도 안정적으로 동작하는 코드를 작성할 수 있다!
